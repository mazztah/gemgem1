<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Advanced Snake Game – Responsive, Scrollend & mit Hindernissen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      user-select: none;
    }
    canvas {
      display: block;
      background: #222;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // Global Settings
    const cellSize = 20; // feste Zellengröße in Pixeln
    let canvas = document.getElementById("gameCanvas");
    let ctx = canvas.getContext("2d");
    
    // Welt: 4x so groß wie der sichtbare Bereich (in Zellen)
    let viewportWidth, viewportHeight;
    let worldWidth, worldHeight;
    
    // Update Canvas-Größe und Welt-Dimensionen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      viewportWidth = canvas.width / cellSize;
      viewportHeight = canvas.height / cellSize;
      // Welt ist 4x so groß wie der Viewport
      worldWidth = viewportWidth * 4;
      worldHeight = viewportHeight * 4;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const TICK_INTERVAL = 150;       // ms pro Tick
    const TARGET_APPLE_COUNT = 80;   // Mehr Äpfel
    const MAX_BOTS = 10;
    const BOT_SPAWN_INTERVAL = 15000;
    const TOUCH_THRESHOLD = 5;       // Minimalbewegung in Pixeln, um Richtung zu ändern

    // Bilder
    const appleImage = new Image();
    appleImage.src = "https://i.ibb.co/YTfFdFqZ/7e89b4f2-893c-4024-95ec-0e8d43cca844.png";
    const botHeadImage = new Image();
    botHeadImage.src = "https://i.ibb.co/chrtCC8z/19ed4cd6-ced8-46d8-a4ab-84a46003d629.png";
    const BOT_HEAD_SIZE = cellSize + 4; // Bot-Köpfe etwas größer

    // Welt-Objekte
    let apples = [];
    let bots = [];
    let obstacles = [];
    let gameOver = false;
    let lastBotSpawnTime = Date.now();

    // Spieler-Schlange (Positionen als Fließkommazahlen in Weltzellen)
    let player = {
      snake: [
        { x: worldWidth/2, y: worldHeight/2 },
        { x: worldWidth/2 - 1, y: worldHeight/2 },
        { x: worldWidth/2 - 2, y: worldHeight/2 }
      ],
      direction: { dx: 1, dy: 0 }, // Standard: nach rechts
      speed: 1
    };

    // Bot-Schlangen
    function createBot() {
      let startX = Math.random() * worldWidth;
      let startY = Math.random() * worldHeight;
      return {
        snake: [
          { x: startX, y: startY },
          { x: startX - 1, y: startY }
        ],
        direction: { dx: Math.cos(Math.random()*2*Math.PI), dy: Math.sin(Math.random()*2*Math.PI) },
        speed: 0.5 + Math.random() * 0.5
      };
    }

    // Apfel spawnen: zufällige ganze Zelle in der Welt
    function spawnApple() {
      let apple = {
        x: Math.floor(Math.random() * worldWidth),
        y: Math.floor(Math.random() * worldHeight)
      };
      apples.push(apple);
    }
    function ensureApples() {
      while(apples.length < TARGET_APPLE_COUNT) {
        spawnApple();
      }
    }

    // Hindernisse: z.B. 30 zufällige Hindernisse, nicht im zentralen Bereich
    function initObstacles() {
      obstacles = [];
      const count = 30;
      for(let i = 0; i < count; i++){
        let ox = Math.floor(Math.random() * worldWidth);
        let oy = Math.floor(Math.random() * worldHeight);
        if(Math.abs(ox - worldWidth/2) < 5 && Math.abs(oy - worldHeight/2) < 5) continue;
        obstacles.push({ x: ox, y: oy });
      }
    }

    function initGame() {
      apples = [];
      bots = [];
      initObstacles();
      ensureApples();
      for(let i = 0; i < 3; i++){
        bots.push(createBot());
      }
    }

    // Prüfe, ob an Zelle (x,y) ein Hindernis liegt
    function isObstacleAt(x, y) {
      for(let obs of obstacles){
        if(obs.x === x && obs.y === y) return true;
      }
      return false;
    }

    // Steuerung: Desktop – Standardrichtungen (Pfeiltasten)
    document.addEventListener("keydown", e => {
      switch(e.key) {
        case "ArrowUp":
          player.direction = { dx: 0, dy: -1 };
          break;
        case "ArrowDown":
          player.direction = { dx: 0, dy: 1 };
          break;
        case "ArrowLeft":
          player.direction = { dx: -1, dy: 0 };
          break;
        case "ArrowRight":
          player.direction = { dx: 1, dy: 0 };
          break;
      }
    });

    // Touch-Steuerung: Nur bei tatsächlicher Fingerbewegung wird die Richtung geändert.
    let touchStartX = 0, touchStartY = 0;
    let touchActive = false;
    canvas.addEventListener("touchstart", e => {
      let touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchActive = true;
    });
    canvas.addEventListener("touchmove", e => {
      if(!touchActive) return;
      let touch = e.touches[0];
      let dx = touch.clientX - touchStartX;
      let dy = touch.clientY - touchStartY;
      if(Math.hypot(dx, dy) >= TOUCH_THRESHOLD) {
        let angle = Math.atan2(dy, dx);
        player.direction = { dx: Math.cos(angle), dy: Math.sin(angle) };
        // Aktualisiere Referenzposition, damit nur echte Bewegungen zählen:
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
      e.preventDefault();
    });
    canvas.addEventListener("touchend", () => {
      touchActive = false;
    });

    // Bewegung: An Wänden und Hindernissen prallt die Schlange ab.
    function moveSnake(snake, direction, speed, grow) {
      let head = snake[0];
      let newHead = { x: head.x + direction.dx * speed, y: head.y + direction.dy * speed };
      
      // Bounce an Weltwänden:
      if(newHead.x < 0) { newHead.x = 0; direction.dx = -direction.dx; }
      else if(newHead.x >= worldWidth) { newHead.x = worldWidth - 0.001; direction.dx = -direction.dx; }
      if(newHead.y < 0) { newHead.y = 0; direction.dy = -direction.dy; }
      else if(newHead.y >= worldHeight) { newHead.y = worldHeight - 0.001; direction.dy = -direction.dy; }
      
      // Bounce an Hindernissen:
      let cellX = Math.floor(newHead.x);
      let cellY = Math.floor(newHead.y);
      if(isObstacleAt(cellX, cellY)) {
        // Richtung invertieren (Bounce)
        direction.dx = -direction.dx;
        direction.dy = -direction.dy;
        newHead = { x: head.x + direction.dx * speed, y: head.y + direction.dy * speed };
        if(isObstacleAt(Math.floor(newHead.x), Math.floor(newHead.y))) {
          newHead = { x: head.x, y: head.y };
        }
      }
      snake.unshift(newHead);
      if(!grow) snake.pop();
    }

    // Spieler aktualisieren: Prüfe Apfel-Kollision (gerundet) und bewege
    function updatePlayer() {
      let head = player.snake[0];
      let newHead = { x: head.x + player.direction.dx * player.speed, y: head.y + player.direction.dy * player.speed };
      let ateApple = false;
      for(let i = 0; i < apples.length; i++){
        if(Math.floor(apples[i].x) === Math.floor(newHead.x) && Math.floor(apples[i].y) === Math.floor(newHead.y)){
          ateApple = true;
          apples.splice(i, 1);
          break;
        }
      }
      moveSnake(player.snake, player.direction, player.speed, ateApple);
    }

    // Bots aktualisieren: Jeder Bot sucht den nächsten Apfel und bewegt sich in 360°.
    function updateBots() {
      bots.forEach(bot => {
        let head = bot.snake[0];
        let target = null, minDist = Infinity;
        apples.forEach(apple => {
          let d = Math.hypot(apple.x - head.x, apple.y - head.y);
          if(d < minDist) {
            minDist = d;
            target = apple;
          }
        });
        if(target) {
          let angle = Math.atan2(target.y - head.y, target.x - head.x);
          bot.direction = { dx: Math.cos(angle), dy: Math.sin(angle) };
        }
        let nextHead = { x: head.x + bot.direction.dx * bot.speed, y: head.y + bot.direction.dy * bot.speed };
        if(nextHead.x < 0) { nextHead.x = 0; bot.direction.dx = -bot.direction.dx; }
        else if(nextHead.x >= worldWidth) { nextHead.x = worldWidth - 0.001; bot.direction.dx = -bot.direction.dx; }
        if(nextHead.y < 0) { nextHead.y = 0; bot.direction.dy = -bot.direction.dy; }
        else if(nextHead.y >= worldHeight) { nextHead.y = worldHeight - 0.001; bot.direction.dy = -bot.direction.dy; }
        let bx = Math.floor(nextHead.x), by = Math.floor(nextHead.y);
        if(isObstacleAt(bx, by)) {
          bot.direction.dx = -bot.direction.dx;
          bot.direction.dy = -bot.direction.dy;
          nextHead = { x: head.x + bot.direction.dx * bot.speed, y: head.y + bot.direction.dy * bot.speed };
          if(isObstacleAt(Math.floor(nextHead.x), Math.floor(nextHead.y))) {
            nextHead = { x: head.x, y: head.y };
          }
        }
        let ateApple = false;
        for(let i = 0; i < apples.length; i++){
          if(Math.floor(apples[i].x) === Math.floor(nextHead.x) && Math.floor(apples[i].y) === Math.floor(nextHead.y)){
            ateApple = true;
            apples.splice(i, 1);
            break;
          }
        }
        moveSnake(bot.snake, bot.direction, bot.speed, ateApple);
      });
    }

    // Kollisionen: Prüfe Head-on-Kollisionen (Spieler vs. Bot-Kopf, Bots vs. Bot-Kopf).
    // Nur bei Kopf-Kollision (d.h. in derselben Zelle) und entgegengesetzten Richtungen.
    function checkCollisions() {
      let pHead = player.snake[0];
      bots.forEach((bot, index) => {
        let bHead = bot.snake[0];
        if(Math.floor(pHead.x) === Math.floor(bHead.x) && Math.floor(pHead.y) === Math.floor(bHead.y)){
          // Kopf-zu-Kopf: Wenn Spieler länger ist, esse den Bot komplett.
          if(player.snake.length > bot.snake.length){
            for(let i = 0; i < bot.snake.length; i++){
              player.snake.push({ ...player.snake[player.snake.length - 1] });
            }
            bots.splice(index, 1);
          } else if(player.snake.length < bot.snake.length){
            gameOver = true;
          }
        }
      });
      // Bots untereinander:
      for(let i = 0; i < bots.length; i++){
        for(let j = i + 1; j < bots.length; j++){
          let headA = bots[i].snake[0];
          let headB = bots[j].snake[0];
          if(Math.floor(headA.x) === Math.floor(headB.x) && Math.floor(headA.y) === Math.floor(headB.y)){
            let dot = bots[i].direction.dx * (-bots[j].direction.dx) + bots[i].direction.dy * (-bots[j].direction.dy);
            if(dot > 0.5){
              if(bots[i].snake.length > bots[j].snake.length){
                bots.splice(j, 1);
                j--;
              } else if(bots[i].snake.length < bots[j].snake.length){
                bots.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }
      }
    }

    // Kamera: Berechne den Offset, sodass der Spieler immer im sichtbaren Bereich zentriert ist (sofern möglich)
    function getCameraOffset() {
      let pHead = player.snake[0];
      let camX = pHead.x * cellSize - canvas.width / 2;
      let camY = pHead.y * cellSize - canvas.height / 2;
      // Stelle sicher, dass der Offset nicht außerhalb der Welt liegt
      camX = Math.max(0, Math.min(camX, worldWidth * cellSize - canvas.width));
      camY = Math.max(0, Math.min(camY, worldHeight * cellSize - canvas.height));
      return { camX, camY };
    }

    // Zeichnen: Welt, Hindernisse, Äpfel, Schlangen, Score
    function draw() {
      ctx.save();
      let { camX, camY } = getCameraOffset();
      ctx.translate(-camX, -camY);

      // Hintergrund der Welt
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, worldWidth * cellSize, worldHeight * cellSize);

      // Hindernisse zeichnen
      ctx.fillStyle = "#555";
      obstacles.forEach(obs => {
        ctx.fillRect(obs.x * cellSize, obs.y * cellSize, cellSize, cellSize);
      });

      // Äpfel zeichnen (als Bild, skaliert)
      let appleSize = cellSize - 4;
      let offset = (cellSize - appleSize) / 2;
      apples.forEach(apple => {
        if(appleImage.complete){
          ctx.drawImage(appleImage, apple.x * cellSize + offset, apple.y * cellSize + offset, appleSize, appleSize);
        } else {
          ctx.fillStyle = "green";
          ctx.fillRect(apple.x * cellSize, apple.y * cellSize, cellSize, cellSize);
        }
      });

      // Spieler-Schlange zeichnen (Körper als Kreise)
      player.snake.forEach(seg => {
        drawCell(seg.x, seg.y, "blue");
      });

      // Bot-Schlangen zeichnen:
      bots.forEach(bot => {
        let head = bot.snake[0];
        let botOffset = (cellSize - BOT_HEAD_SIZE) / 2;
        if(botHeadImage.complete){
          ctx.drawImage(botHeadImage, head.x * cellSize + botOffset, head.y * cellSize + botOffset, BOT_HEAD_SIZE, BOT_HEAD_SIZE);
        } else {
          drawCell(head.x, head.y, "red");
        }
        for(let i = 1; i < bot.snake.length; i++){
          drawCell(bot.snake[i].x, bot.snake[i].y, "red");
        }
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.fillText(bot.snake.length, head.x * cellSize, head.y * cellSize);
      });

      // Spieler-Score im sichtbaren Bereich (oben links)
      let camOffset = getCameraOffset();
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + player.snake.length, camOffset.camX + 10, camOffset.camY + 30);

      ctx.restore();
    }

    // Zeichnet eine Zelle als Kreis (für Schlangensegmente)
    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      let cx = x * cellSize + cellSize/2;
      let cy = y * cellSize + cellSize/2;
      let radius = cellSize/2 - 2;
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    // Haupt-Spielschleife
    function gameTick() {
      if(gameOver) return;
      updatePlayer();
      updateBots();
      checkCollisions();
      ensureApples();
      if(Date.now() - lastBotSpawnTime > BOT_SPAWN_INTERVAL && bots.length < MAX_BOTS){
        bots.push(createBot());
        lastBotSpawnTime = Date.now();
      }
      draw();
    }

    initGame();
    setInterval(gameTick, TICK_INTERVAL);
  </script>
</body>
</html>
