<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Advanced Snake Game – Scrollendes Spielfeld & Hindernisse</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { 
      margin: 0; 
      background: #111; 
      overflow: hidden; 
      user-select: none;
    }
    canvas { 
      display: block;
      background: #222; 
      border: 2px solid #555; 
      touch-action: none; 
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1200" height="800"></canvas>
  <script>
    // Konfiguration
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const cellSize = 20;
    // Viewport-Größe (in Zellen) entspricht Canvas
    const viewportWidth = canvas.width / cellSize;  // z.B. 60
    const viewportHeight = canvas.height / cellSize; // z.B. 40
    // Welt ist 4× so groß
    const worldWidth = viewportWidth * 4;   // 240 Zellen
    const worldHeight = viewportHeight * 4; // 160 Zellen

    const TICK_INTERVAL = 150;       // ms pro Tick
    const TARGET_APPLE_COUNT = 80;   // Mehr Äpfel
    const MAX_BOTS = 10;
    const BOT_SPAWN_INTERVAL = 15000;
    const TOUCH_THRESHOLD = 5;       // Minimalbewegung in Pixeln, um Richtungsänderung auszulösen

    // Bilder
    const appleImage = new Image();
    appleImage.src = "https://i.ibb.co/YTfFdFqZ/7e89b4f2-893c-4024-95ec-0e8d43cca844.png";
    const botHeadImage = new Image();
    botHeadImage.src = "https://i.ibb.co/chrtCC8z/19ed4cd6-ced8-46d8-a4ab-84a46003d629.png";
    const BOT_HEAD_SIZE = cellSize + 4; // Bot-Köpfe etwas größer

    // Welt-Objekte
    let apples = [];
    let bots = [];
    let obstacles = [];
    let gameOver = false;
    let lastBotSpawnTime = Date.now();

    // Spieler-Schlange (Positionen als Fließkommazahlen in Weltzellen)
    let player = {
      snake: [
        { x: worldWidth/2, y: worldHeight/2 },
        { x: worldWidth/2 - 1, y: worldHeight/2 },
        { x: worldWidth/2 - 2, y: worldHeight/2 }
      ],
      // Standardrichtung: nach rechts (als normalisierter Vektor)
      direction: { dx: 1, dy: 0 },
      speed: 1
    };

    // Bot-Schlangen
    function createBot() {
      let startX = Math.random() * worldWidth;
      let startY = Math.random() * worldHeight;
      return {
        snake: [
          { x: startX, y: startY },
          { x: startX - 1, y: startY }
        ],
        direction: { dx: Math.cos(Math.random()*2*Math.PI), dy: Math.sin(Math.random()*2*Math.PI) },
        speed: 0.5 + Math.random() * 0.5
      };
    }

    // Apfel spawnen: zufällige ganze Zelle in der Welt
    function spawnApple() {
      let apple = {
        x: Math.floor(Math.random() * worldWidth),
        y: Math.floor(Math.random() * worldHeight)
      };
      apples.push(apple);
    }
    function ensureApples() {
      while(apples.length < TARGET_APPLE_COUNT) {
        spawnApple();
      }
    }

    // Hindernisse initialisieren: z.B. 30 zufällige Hindernisse
    function initObstacles() {
      obstacles = [];
      const count = 30;
      for(let i = 0; i < count; i++){
        let ox = Math.floor(Math.random() * worldWidth);
        let oy = Math.floor(Math.random() * worldHeight);
        // Vermeide den Startbereich des Spielers (in der Mitte)
        if(Math.abs(ox - worldWidth/2) < 5 && Math.abs(oy - worldHeight/2) < 5) continue;
        obstacles.push({ x: ox, y: oy });
      }
    }

    function initGame() {
      apples = [];
      bots = [];
      initObstacles();
      ensureApples();
      for(let i = 0; i < 3; i++){
        bots.push(createBot());
      }
    }

    // Hilfsfunktion: Prüfe, ob in der Zelle (x,y) ein Hindernis liegt
    function isObstacleAt(x, y) {
      for(let obs of obstacles){
        if(obs.x === x && obs.y === y) return true;
      }
      return false;
    }

    // Steuerung: Desktop-Pfeiltasten (Standardrichtungen)
    document.addEventListener("keydown", e => {
      switch(e.key) {
        case "ArrowUp":
          player.direction = { dx: 0, dy: -1 };
          break;
        case "ArrowDown":
          player.direction = { dx: 0, dy: 1 };
          break;
        case "ArrowLeft":
          player.direction = { dx: -1, dy: 0 };
          break;
        case "ArrowRight":
          player.direction = { dx: 1, dy: 0 };
          break;
      }
    });

    // Touch-Steuerung: Nur bei tatsächlicher Fingerbewegung wird die Richtung aktualisiert.
    let touchStartX = 0, touchStartY = 0;
    let touchActive = false;
    canvas.addEventListener("touchstart", e => {
      let touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchActive = true;
    });
    canvas.addEventListener("touchmove", e => {
      if(!touchActive) return;
      let touch = e.touches[0];
      let dx = touch.clientX - touchStartX;
      let dy = touch.clientY - touchStartY;
      if(Math.hypot(dx, dy) >= TOUCH_THRESHOLD) {
        let angle = Math.atan2(dy, dx);
        player.direction = { dx: Math.cos(angle), dy: Math.sin(angle) };
        // Nur aktualisieren, wenn der Finger sich bewegt – sonst bleibt die Richtung gleich.
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
      e.preventDefault();
    });
    canvas.addEventListener("touchend", () => {
      touchActive = false;
    });

    // Bewegung: Bouncing an Wänden und Hindernissen.
    // Hier wird die neue Kopfposition berechnet; bei Kollision mit Wand/Hindernis wird abprallt.
    function moveSnake(snake, direction, speed, grow) {
      let head = snake[0];
      let newHead = { x: head.x + direction.dx * speed, y: head.y + direction.dy * speed };

      // Bounce an Weltbegrenzungen:
      if(newHead.x < 0) { newHead.x = 0; direction.dx = -direction.dx; }
      else if(newHead.x >= worldWidth) { newHead.x = worldWidth - 0.001; direction.dx = -direction.dx; }
      if(newHead.y < 0) { newHead.y = 0; direction.dy = -direction.dy; }
      else if(newHead.y >= worldHeight) { newHead.y = worldHeight - 0.001; direction.dy = -direction.dy; }

      // Bounce an Hindernissen:
      let cellX = Math.floor(newHead.x);
      let cellY = Math.floor(newHead.y);
      if(isObstacleAt(cellX, cellY)) {
        // Reflektiere Richtung und berechne neue Kopfposition
        direction.dx = -direction.dx;
        direction.dy = -direction.dy;
        newHead = { x: head.x + direction.dx * speed, y: head.y + direction.dy * speed };
        // Falls immer noch im Hindernis, verbleibe an alter Position.
        if(isObstacleAt(Math.floor(newHead.x), Math.floor(newHead.y))) {
          newHead = { x: head.x, y: head.y };
        }
      }

      snake.unshift(newHead);
      if(!grow) snake.pop();
    }

    // Spieler aktualisieren
    function updatePlayer() {
      let head = player.snake[0];
      let newHead = { x: head.x + player.direction.dx * player.speed, y: head.y + player.direction.dy * player.speed };
      // Bounce an Wänden und Hindernissen wird in moveSnake behandelt.
      let ateApple = false;
      for(let i = 0; i < apples.length; i++){
        // Prüfe Kollision in Zellen (gerundet)
        if(Math.floor(apples[i].x) === Math.floor(newHead.x) && Math.floor(apples[i].y) === Math.floor(newHead.y)){
          ateApple = true;
          apples.splice(i, 1);
          break;
        }
      }
      moveSnake(player.snake, player.direction, player.speed, ateApple);
    }

    // Bots aktualisieren: Jeder Bot sucht den nächsten Apfel und bewegt sich 360° in dessen Richtung.
    function updateBots() {
      bots.forEach(bot => {
        let head = bot.snake[0];
        let target = null, minDist = Infinity;
        apples.forEach(apple => {
          let d = Math.hypot(apple.x - head.x, apple.y - head.y);
          if(d < minDist) {
            minDist = d;
            target = apple;
          }
        });
        if(target) {
          let angle = Math.atan2(target.y - head.y, target.x - head.x);
          bot.direction = { dx: Math.cos(angle), dy: Math.sin(angle) };
        }
        let nextHead = { x: head.x + bot.direction.dx * bot.speed, y: head.y + bot.direction.dy * bot.speed };
        // Bounce an Weltbegrenzungen und Hindernissen für Bots
        if(nextHead.x < 0) { nextHead.x = 0; bot.direction.dx = -bot.direction.dx; }
        else if(nextHead.x >= worldWidth) { nextHead.x = worldWidth - 0.001; bot.direction.dx = -bot.direction.dx; }
        if(nextHead.y < 0) { nextHead.y = 0; bot.direction.dy = -bot.direction.dy; }
        else if(nextHead.y >= worldHeight) { nextHead.y = worldHeight - 0.001; bot.direction.dy = -bot.direction.dy; }
        let bx = Math.floor(nextHead.x), by = Math.floor(nextHead.y);
        if(isObstacleAt(bx, by)) {
          bot.direction.dx = -bot.direction.dx;
          bot.direction.dy = -bot.direction.dy;
          nextHead = { x: head.x + bot.direction.dx * bot.speed, y: head.y + bot.direction.dy * bot.speed };
          if(isObstacleAt(Math.floor(nextHead.x), Math.floor(nextHead.y))) {
            nextHead = { x: head.x, y: head.y };
          }
        }
        let ateApple = false;
        for(let i = 0; i < apples.length; i++){
          if(Math.floor(apples[i].x) === Math.floor(nextHead.x) && Math.floor(apples[i].y) === Math.floor(nextHead.y)){
            ateApple = true;
            apples.splice(i, 1);
            break;
          }
        }
        moveSnake(bot.snake, bot.direction, bot.speed, ateApple);
      });
    }

    // Kollisionen prüfen: Nur Kopf-zu-Kopf-Kollisionen zählen
    function checkCollisions() {
      let pHead = player.snake[0];
      // Prüfe Spieler vs. Bot-Köpfe
      bots.forEach(bot => {
        let bHead = bot.snake[0];
        // Prüfe, ob beide in derselben Zelle liegen
        if(Math.floor(pHead.x) === Math.floor(bHead.x) && Math.floor(pHead.y) === Math.floor(bHead.y)){
          // Zusätzlich: Head-on-Erkennung: Prüfe, ob die Richtungen nahezu entgegengesetzt sind.
          let dot = player.direction.dx * (-bot.direction.dx) + player.direction.dy * (-bot.direction.dy);
          if(dot > 0.5) { // Kopf an Kopf: Game Over
            gameOver = true;
          }
        }
      });
      // Prüfe Bots untereinander: Kopf-zu-Kopf-Kollisionen; bei solchen kollidieren die Schlangen – der kleinere Bot wird entfernt.
      for(let i = 0; i < bots.length; i++){
        for(let j = i + 1; j < bots.length; j++){
          let headA = bots[i].snake[0];
          let headB = bots[j].snake[0];
          if(Math.floor(headA.x) === Math.floor(headB.x) && Math.floor(headA.y) === Math.floor(headB.y)){
            let dot = bots[i].direction.dx * (-bots[j].direction.dx) + bots[i].direction.dy * (-bots[j].direction.dy);
            if(dot > 0.5){
              // Entferne den kleineren Bot
              if(bots[i].snake.length > bots[j].snake.length){
                bots.splice(j, 1);
                j--;
              } else if(bots[i].snake.length < bots[j].snake.length){
                bots.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }
      }
    }

    // Kamera: Berechne den Offset, sodass der Spieler zentriert ist (innerhalb der Weltbegrenzungen)
    function getCameraOffset() {
      let pHead = player.snake[0];
      let camX = pHead.x * cellSize - canvas.width / 2;
      let camY = pHead.y * cellSize - canvas.height / 2;
      camX = Math.max(0, Math.min(camX, worldWidth * cellSize - canvas.width));
      camY = Math.max(0, Math.min(camY, worldHeight * cellSize - canvas.height));
      return { camX, camY };
    }

    // Zeichnen: Wende Kamera-Translation an und zeichne Welt, Äpfel, Hindernisse, Schlangen.
    function draw() {
      ctx.save();
      // Kamera-Offset
      let { camX, camY } = getCameraOffset();
      ctx.translate(-camX, -camY);

      // Hintergrund (Welt)
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, worldWidth * cellSize, worldHeight * cellSize);

      // Zeichne Hindernisse
      ctx.fillStyle = "#555";
      obstacles.forEach(obs => {
        ctx.fillRect(obs.x * cellSize, obs.y * cellSize, cellSize, cellSize);
      });

      // Zeichne Äpfel (als Bild, skaliert)
      let appleSize = cellSize - 4;
      let offset = (cellSize - appleSize) / 2;
      apples.forEach(apple => {
        if(appleImage.complete){
          ctx.drawImage(appleImage, apple.x * cellSize + offset, apple.y * cellSize + offset, appleSize, appleSize);
        } else {
          ctx.fillStyle = "green";
          ctx.fillRect(apple.x * cellSize, apple.y * cellSize, cellSize, cellSize);
        }
      });

      // Zeichne Spieler-Schlange (Körper als Kreise)
      player.snake.forEach(seg => {
        drawCell(seg.x, seg.y, "blue");
      });

      // Zeichne Bot-Schlangen:
      bots.forEach(bot => {
        // Bot-Kopf: Zeichne mit Bild und größerer Größe
        let head = bot.snake[0];
        let botOffset = (cellSize - BOT_HEAD_SIZE) / 2;
        if(botHeadImage.complete){
          ctx.drawImage(botHeadImage, head.x * cellSize + botOffset, head.y * cellSize + botOffset, BOT_HEAD_SIZE, BOT_HEAD_SIZE);
        } else {
          drawCell(head.x, head.y, "red");
        }
        // Rest der Bot-Schlange
        for(let i = 1; i < bot.snake.length; i++){
          drawCell(bot.snake[i].x, bot.snake[i].y, "red");
        }
        // Score-Anzeige (Länge) am Kopf
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.fillText(bot.snake.length, head.x * cellSize, head.y * cellSize);
      });

      // Spieler-Score (oben links im Viewport)
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + player.snake.length, camX + 10, camY + 30);

      ctx.restore();
    }

    // Zeichnet eine Zelle als Kreis (für Schlangensegmente)
    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      let cx = x * cellSize + cellSize/2;
      let cy = y * cellSize + cellSize/2;
      let radius = cellSize/2 - 2;
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    // Haupt-Spielschleife
    function gameTick() {
      if(gameOver) return;
      updatePlayer();
      updateBots();
      checkCollisions();
      ensureApples();
      if(Date.now() - lastBotSpawnTime > BOT_SPAWN_INTERVAL && bots.length < MAX_BOTS){
        bots.push(createBot());
        lastBotSpawnTime = Date.now();
      }
      draw();
    }

    initGame();
    setInterval(gameTick, TICK_INTERVAL);
  </script>
</body>
</html>
