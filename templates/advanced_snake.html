<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Advanced Snake Game – 360° Touch & Bild-Äpfel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { 
      margin: 0; 
      background: #111; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      user-select: none; 
      overflow: hidden; 
    }
    canvas { 
      background: #222; 
      border: 2px solid #555; 
      touch-action: none; 
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1200" height="800"></canvas>
  <script>
    // CONFIGURATION
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const cellSize = 20;
    const gridWidth = canvas.width / cellSize;
    const gridHeight = canvas.height / cellSize;
    const TICK_INTERVAL = 150;       // ms per tick
    const TARGET_APPLE_COUNT = 50;
    const MAX_BOTS = 10;
    const BOT_SPAWN_INTERVAL = 15000;
    const TOUCH_THRESHOLD = 5;       // Minimaler Pixelversatz, um Richtungsänderung auszulösen

    // Bilder
    const appleImage = new Image();
    appleImage.src = "https://i.ibb.co/YTfFdFqZ/7e89b4f2-893c-4024-95ec-0e8d43cca844.png";
    const botHeadImage = new Image();
    botHeadImage.src = "https://i.ibb.co/chrtCC8z/19ed4cd6-ced8-46d8-a4ab-84a46003d629.png";

    let apples = [];
    let bots = [];
    let gameOver = false;
    let lastBotSpawnTime = Date.now();

    // Spieler-Snake: Positionen als Fließkommazahlen
    let player = {
      snake: [
        { x: gridWidth/2, y: gridHeight/2 },
        { x: gridWidth/2 - 1, y: gridHeight/2 },
        { x: gridWidth/2 - 2, y: gridHeight/2 }
      ],
      // Standardrichtung: nach rechts (als normalisierter Vektor)
      direction: { dx: 1, dy: 0 },
      speed: 1  // Geschwindigkeit in "Zellen pro Tick"
    };

    // Bot-Snake: Jeder Bot hat eine eigene Snake und Richtung (360° möglich)
    function createBot() {
      let startX = Math.random() * gridWidth;
      let startY = Math.random() * gridHeight;
      return {
        snake: [
          { x: startX, y: startY },
          { x: startX - 1, y: startY }
        ],
        // Initiale Richtung: zufällig
        direction: { dx: Math.cos(Math.random()*2*Math.PI), dy: Math.sin(Math.random()*2*Math.PI) },
        speed: 0.5 + Math.random() * 0.5
      };
    }

    // Apfel spawnen: zufällige Gitterposition (ganzzahlig)
    function spawnApple() {
      let apple = {
        x: Math.floor(Math.random() * gridWidth),
        y: Math.floor(Math.random() * gridHeight)
      };
      apples.push(apple);
    }
    function ensureApples() {
      while(apples.length < TARGET_APPLE_COUNT) {
        spawnApple();
      }
    }
    function initGame() {
      apples = [];
      bots = [];
      ensureApples();
      for(let i = 0; i < 3; i++){
        bots.push(createBot());
      }
    }

    // Steuerung für Desktop (Pfeiltasten bleiben erhalten, allerdings
    // werden hier nur Standardrichtungen genutzt – für 360°-Steuerung primär Touch)
    document.addEventListener("keydown", e => {
      switch(e.key) {
        case "ArrowUp":
          player.direction = { dx: 0, dy: -1 };
          break;
        case "ArrowDown":
          player.direction = { dx: 0, dy: 1 };
          break;
        case "ArrowLeft":
          player.direction = { dx: -1, dy: 0 };
          break;
        case "ArrowRight":
          player.direction = { dx: 1, dy: 0 };
          break;
      }
    });

    // Touch-Steuerung: Nur bei tatsächlicher Bewegung wird die Richtung neu berechnet.
    let touchStartX = 0, touchStartY = 0;
    let touchActive = false;
    canvas.addEventListener("touchstart", e => {
      let touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchActive = true;
    });
    canvas.addEventListener("touchmove", e => {
      if(!touchActive) return;
      let touch = e.touches[0];
      let dx = touch.clientX - touchStartX;
      let dy = touch.clientY - touchStartY;
      if(Math.hypot(dx, dy) >= TOUCH_THRESHOLD) {
        let angle = Math.atan2(dy, dx);
        player.direction = { dx: Math.cos(angle), dy: Math.sin(angle) };
        // Update Referenzposition, damit nur relative Bewegungen zählen:
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
      e.preventDefault();
    });
    canvas.addEventListener("touchend", () => {
      touchActive = false;
    });

    // Wrap-Around: Bei Überschreiten des Spielfelds taucht man am gegenüberliegenden Rand auf.
    function wrapPosition(pos) {
      if(pos.x < 0) pos.x += gridWidth;
      if(pos.x >= gridWidth) pos.x -= gridWidth;
      if(pos.y < 0) pos.y += gridHeight;
      if(pos.y >= gridHeight) pos.y -= gridHeight;
    }

    // Verschiebe eine Snake: Neuer Kopf wird hinzugefügt. Wenn sie nicht "wachsen" soll, wird das letzte Segment entfernt.
    function moveSnake(snake, direction, speed, grow) {
      let head = snake[0];
      let newHead = { 
        x: head.x + direction.dx * speed, 
        y: head.y + direction.dy * speed 
      };
      wrapPosition(newHead);
      snake.unshift(newHead);
      if(!grow) snake.pop();
    }

    // Spieler aktualisieren: Bewegungsrichtung wird angewendet, Apfelkollision über Distanzprüfung.
    function updatePlayer() {
      let head = player.snake[0];
      let newHead = { 
        x: head.x + player.direction.dx * player.speed, 
        y: head.y + player.direction.dy * player.speed 
      };
      wrapPosition(newHead);
      let ateApple = false;
      for(let i = 0; i < apples.length; i++){
        if(Math.hypot(apples[i].x - newHead.x, apples[i].y - newHead.y) < 0.5) {
          ateApple = true;
          apples.splice(i, 1);
          break;
        }
      }
      moveSnake(player.snake, player.direction, player.speed, ateApple);
    }

    // Bots aktualisieren: Jeder Bot sucht den nächsten Apfel und berechnet einen 360°-Winkel.
    function updateBots() {
      bots.forEach(bot => {
        let head = bot.snake[0];
        let target = null, minDist = Infinity;
        apples.forEach(apple => {
          let d = Math.hypot(apple.x - head.x, apple.y - head.y);
          if(d < minDist) {
            minDist = d;
            target = apple;
          }
        });
        if(target) {
          let angle = Math.atan2(target.y - head.y, target.x - head.x);
          bot.direction = { dx: Math.cos(angle), dy: Math.sin(angle) };
        }
        let nextHead = { 
          x: head.x + bot.direction.dx * bot.speed, 
          y: head.y + bot.direction.dy * bot.speed 
        };
        wrapPosition(nextHead);
        let ateApple = false;
        for(let i = 0; i < apples.length; i++){
          if(Math.hypot(apples[i].x - nextHead.x, apples[i].y - nextHead.y) < 0.5) {
            ateApple = true;
            apples.splice(i, 1);
            break;
          }
        }
        moveSnake(bot.snake, bot.direction, bot.speed, ateApple);
      });
    }

    // Kollisionsprüfung: Spieler vs. Bots sowie Bots untereinander. Wird der Kopf kollidieren, "frisst" der längere Snake-Körper den kleineren.
    function checkCollisions() {
      let pHead = player.snake[0];
      bots.forEach((bot, index) => {
        let bHead = bot.snake[0];
        if(Math.hypot(pHead.x - bHead.x, pHead.y - bHead.y) < 0.5) {
          if(player.snake.length > bot.snake.length) {
            // Spieler frisst den Bot: Hänge so viele Segmente an den Spieler an wie der Bot hat.
            for(let i = 0; i < bot.snake.length; i++){
              player.snake.push({ ...player.snake[player.snake.length - 1] });
            }
            bots.splice(index, 1);
          } else if(player.snake.length < bot.snake.length) {
            gameOver = true;
          }
        }
      });
      // Bots untereinander:
      for(let i = 0; i < bots.length; i++){
        for(let j = i + 1; j < bots.length; j++){
          let headA = bots[i].snake[0];
          let headB = bots[j].snake[0];
          if(Math.hypot(headA.x - headB.x, headA.y - headB.y) < 0.5){
            if(bots[i].snake.length > bots[j].snake.length){
              for(let k = 0; k < bots[j].snake.length; k++){
                bots[i].snake.push({ ...bots[i].snake[bots[i].snake.length - 1] });
              }
              bots.splice(j, 1);
              j--;
            } else if(bots[i].snake.length < bots[j].snake.length){
              for(let k = 0; k < bots[i].snake.length; k++){
                bots[j].snake.push({ ...bots[j].snake[bots[j].snake.length - 1] });
              }
              bots.splice(i, 1);
              i--;
              break;
            }
          }
        }
      }
    }

    // Zeichnet eine Zelle als Kreis – für Spieler und den Schwanz der Bots.
    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      let cx = x * cellSize + cellSize/2;
      let cy = y * cellSize + cellSize/2;
      let radius = cellSize/2 - 2;
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function draw() {
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Äpfel zeichnen als Bild, skaliert (z. B. 16x16 bei cellSize=20)
      let appleSize = cellSize - 4;
      let offset = (cellSize - appleSize) / 2;
      apples.forEach(apple => {
        if(appleImage.complete){
          ctx.drawImage(appleImage, apple.x * cellSize + offset, apple.y * cellSize + offset, appleSize, appleSize);
        } else {
          ctx.fillStyle = "green";
          ctx.fillRect(apple.x * cellSize, apple.y * cellSize, cellSize, cellSize);
        }
      });
      
      // Spieler-Snake zeichnen (blau)
      player.snake.forEach(seg => {
        drawCell(seg.x, seg.y, "blue");
      });
      
      // Bot-Snakes zeichnen:
      bots.forEach(bot => {
        // Zeichne den Kopf des Bots mit dem Bild, falls geladen
        let head = bot.snake[0];
        if(botHeadImage.complete){
          ctx.drawImage(botHeadImage, head.x * cellSize + offset, head.y * cellSize + offset, appleSize, appleSize);
        } else {
          drawCell(head.x, head.y, "red");
        }
        // Zeichne den Rest der Bot-Snake als Kreise
        for(let i = 1; i < bot.snake.length; i++){
          drawCell(bot.snake[i].x, bot.snake[i].y, "red");
        }
        // Zeige den Score (Länge) des Bots an
        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.fillText(bot.snake.length, head.x * cellSize, head.y * cellSize);
      });
      
      // Spieler-Score
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + player.snake.length, 10, 30);
    }

    function gameTick() {
      if(gameOver) return;
      updatePlayer();
      updateBots();
      checkCollisions();
      ensureApples();
      if(Date.now() - lastBotSpawnTime > BOT_SPAWN_INTERVAL && bots.length < MAX_BOTS){
        bots.push(createBot());
        lastBotSpawnTime = Date.now();
      }
      draw();
    }

    initGame();
    setInterval(gameTick, TICK_INTERVAL);
  </script>
</body>
</html>
